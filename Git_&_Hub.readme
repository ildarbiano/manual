git config --global user.email "il.v.matveev@yandex.ru"
git config --global http.sslVerify false
git config --list

git show-ref
git branch -vv		 		покажет какие ветки есть локально и с какими внешними ветками связаны.
git remote -v 				покажет удалённый репозиторий

git remote add origin https://github.com/ildarbiano/manual.git
git pull origin main
git add .
git 
git commit				создаёт/продлевает ветку С1>>C2
git commit -m "first commit"		C2>>C"first commit"

git push -u origin master		ключ -u означает "master". Смысл использовать ключ -u есть только при пуше новых веток, для существующих (связанных с удалёнными) веток каждый раз перезаписывать связку необязательно.
С ключом -u (полный вариант --set-upstream) вы создаёте (если ещё не существует) в удалённом репозитории ветку, соответствующую вашей локальной и связываете их:
		В remote/branchname будет производиться push в локальную ветку branchname
		Из remote/branchname будет производиться pull в локальную ветку branchname
Для master это актуально, только если вы пушите в пустой репозиторий. Если клонировали (после git clone) - соответствие ветвей уже настроено. А вот как только вы создадите новую локальную ветвь и захотите её запушить на remote, вам понадобится ключ -u.

git checkout another_branch		перенесёт нас на новую ветку в момент, когда мы ещё не коммитили изменения
git checkout -b [yourbranchname]	создать новую ветку и переключиться на неё с помощью одной команды.
git branch another_branch		создать новую ветку, но не переключаться на неё.

git merge bugFix			merge ветки bugFix в ветку, на которой находишься, git status .
git merge				слияние или просто мердж. Слияния в Git создают особый вид коммита, который имеет сразу двух родителей. Коммит с двумя родителями обычно означает, что мы хотим объединить изменения из одного коммита с другим коммитом и всеми их родительскими коммитами.

git rebase bugFix			merge ветки bugFix в ветку, на которой находишься, git status (main), - сдвинет изменения из bugFix прямо на вершину ветки main. Благодаря этому всё будет выглядеть, как будто эти изменения делались последовательно, хотя на самом деле - параллельно.
git rebase				another способ объединения изменений в ветках. Git по сути копирует набор коммитов и переносит их в другое место. Несмотря на то, что это звучит достаточно непонятно, преимущество rebase в том, что c его помощью можно делать чистые и красивые линейные последовательности коммитов. История коммитов будет чище, если вы применяете rebase.

HEAD - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данный момент работаем.
HEAD всегда указывает на последний коммит из вашего локального дерева. Большинство команд Git, изменяющих рабочее дерево, начнут с изменения HEAD. Обычно HEAD указывает на имя ветки (например, bugFix). Когда вы делаете коммит, статус ветки bugFix меняется и это изменение видно через HEAD.
git checkout [hash]			Репозиторий в состоянии detached HEAD, то есть не находится ни на какой ветке!
git log					чтобы найти хеш нужного коммита. Более того, хеши в реальном репозитории Git намного более длинные. Например, [hash] для коммита, который приведён в предыдущем уровне - fed2da64c0efc5293610bdd892f82a58e8cbc5d8. Не очень просто для произношения =) Хорошая новость в том, что Git достаточно умён в работе с [hash]. Ему нужны лишь первые несколько символов для того, чтобы идентифицировать конкретный коммит. Так что можно написать просто fed2 вместо колбасы выше.
С относительными ссылками можно начать с какого-либо удобного места (например, с ветки bugFix или от HEAD) и двигаться от него
Относительные ссылки - мощный инструмент, но мы покажем два простых способа использования:
	Перемещение на один коммит назад ^
	Перемещение на несколько коммитов назад ~<num>
оператор каретки (^). Когда мы добавляем его к имени ссылки, Git воспринимает это как указание найти родителя указанного коммита.
git checkout main^			переместит, detache/отделит HEAD на "первый родитель commit ветки main"
git checkout main^^			переместит, detache/отделит HEAD на "прародитель (родитель родителя) commit ветки main"
git checkout [hash]
git checkout HEAD^^
git checkout HEAD~4			после ~ число коммитов, через которые надо пройти, чтобы переместит, detache/отделит HEAD на 4-четыре commit по той ветке на которой находимся.
git branch -f main HEAD~3		напрямую прикрепит ветку main к коммиту при помощи опции -f принудительно переместит ветку main к commit, на три commit родителя назад от HEAD.
git branch -f main [hash]		напрямую прикрепит ветку main к коммиту при помощи опции -f принудительно переместит ветку main к commit с [hash].
git checkout HEAD~1			переместит, detache/отделит HEAD на 1-один commit по той ветке на которой находимся.		
git branch -f bugFix HEAD~1		напрямую прикрепит ветку bugFix к коммиту при помощи опции -f принудительно переместит ветку bugFix к commit, на один commit родителя назад от HEAD.

git reset HEAD~2			отменяет изменения, перенося ссылку по ветке [git status] назад, на более старый коммит. Это своего рода "переписывание истории"; git reset перенесёт ветку назад, как будто некоторых коммитов вовсе и не было. Reset отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи.

git revert HEAD				Чтобы отменить изменения и поделиться отменёнными изменениями с остальными, на ветке по git remote -v.