git config --global user.email "il.v.matveev@yandex.ru"
git config --global http.sslVerify false
git config --list

git show-ref
git branch -vv		 		покажет какие ветки есть локально и с какими внешними ветками связаны.
git remote -v 				покажет удалённый репозиторий

git remote add origin https://github.com/ildarbiano/manual.git
git pull origin main
git add .
git 
git commit				создаёт/продлевает ветку С1>>C2
git commit -m "first commit"		C2>>C"first commit"

git push -u origin HEAD:{{another_branch}}
git push -u origin master		ключ -u означает "master". Смысл использовать ключ -u есть только при пуше новых веток, для существующих (связанных с удалёнными) веток каждый раз перезаписывать связку необязательно.
С ключом -u (полный вариант --set-upstream) вы создаёте (если ещё не существует) в удалённом репозитории ветку, соответствующую вашей локальной и связываете их:
		В remote/branchname будет производиться push в локальную ветку branchname
		Из remote/branchname будет производиться pull в локальную ветку branchname
Для master это актуально, только если вы пушите в пустой репозиторий. Если клонировали (после git clone) - соответствие ветвей уже настроено. А вот как только вы создадите новую локальную ветвь и захотите её запушить на remote, вам понадобится ключ -u.

git checkout {{another_branch}}		перенесёт нас на новую ветку в момент, когда мы ещё не коммитили изменения
git checkout -f {{another_branch}}	перенесёт на новую ветку в момент, форс - в любом случае, с удалением коммитов ветки, в которой сейчас находимся.
git checkout -b {{new_branch_name}}	создать новую ветку и переключиться на неё с помощью одной команды.
git branch {{another_branch}}		создать новую ветку, но не переключаться на неё.

git merge bugFix			merge ветки bugFix в ветку, на которой находишься, git status .
git merge				слияние или просто мердж. Слияния в Git создают особый вид коммита, который имеет сразу двух родителей. Коммит с двумя родителями обычно означает, что мы хотим объединить изменения из одного коммита с другим коммитом и всеми их родительскими коммитами.

git rebase bugFix			merge ветки bugFix в ветку, на которой находишься, git status (main), - сдвинет изменения из bugFix прямо на вершину ветки main. Благодаря этому всё будет выглядеть, как будто эти изменения делались последовательно, хотя на самом деле - параллельно.
git rebase				another способ объединения изменений в ветках. Git по сути копирует набор коммитов и переносит их в другое место. Несмотря на то, что это звучит достаточно непонятно, преимущество rebase в том, что c его помощью можно делать чистые и красивые линейные последовательности коммитов. История коммитов будет чище, если вы применяете rebase.
git rebase caption main			merge ветки caption в ветку main, - сдвинет изменения из caption прямо на вершину ветки main, с передачей * main по git status				Благодаря этому всё будет выглядеть, как будто эти изменения делались последовательно, хотя на самом деле - параллельно.

HEAD  				это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данный момент работаем.
HEAD всегда указывает на последний коммит из вашего локального дерева. Большинство команд Git, изменяющих рабочее дерево, начнут с изменения HEAD. Обычно HEAD указывает на имя ветки (например, bugFix). Когда вы делаете коммит, статус ветки bugFix меняется и это изменение видно через HEAD.
git checkout [hash]			Репозиторий в состоянии detached HEAD, то есть не находится ни на какой ветке!
git log					чтобы найти хеш нужного коммита. Более того, хеши в реальном репозитории Git намного более длинные. Например, [hash] для коммита, который приведён в предыдущем уровне - fed2da64c0efc5293610bdd892f82a58e8cbc5d8. Не очень просто для произношения =) Хорошая новость в том, что Git достаточно умён в работе с [hash]. Ему нужны лишь первые несколько символов для того, чтобы идентифицировать конкретный коммит. Так что можно написать просто fed2 вместо колбасы выше.
С относительными ссылками можно начать с какого-либо удобного места (например, с ветки bugFix или от HEAD) и двигаться от него
Относительные ссылки - мощный инструмент, но мы покажем два простых способа использования:
	Перемещение на один коммит назад ^
	Перемещение на несколько коммитов назад ~<num>
в отличие от количества коммитов, на которые нужно откатиться назад (как делает ~), номер после ^ определяет, на какого из родителей мерджа надо перейти. Учитывая, что мерджевый коммит имеет двух родителей, просто указать ^ нельзя. Git по умолчанию перейдёт на "первого" родителя коммита, но указание номера после ^ изменяет это поведение. Когда мы добавляем оператор каретки (^) к имени ссылки, Git воспринимает это как указание найти родителя указанного коммита.
git checkout main^			переместит, detache/отделит HEAD на "первый родитель commit ветки main".
git checkout main^2			переместит, detache/отделит HEAD на "первого родителя commit 2-второй ветки которая вливалась в ветку main".
git checkout main^^			переместит, detache/отделит HEAD на "прародитель (родитель родителя) commit ветки main".
git checkout <hash>
git checkout HEAD^^
git checkout HEAD~^2~2			переместит, detache/отделит HEAD на "первого родителя commit 2-второй ветки которая вливалась в ветку main, а от туда на 2-два коммита раньше". Переместив, detache/отделив HEAD можно основать новую ветку git checkout -b <new_branch_name> на этом коммите, с передачей ветке <new_branch_name> * по git status.
git checkout HEAD~4			после ~ число коммитов, через которые надо пройти, чтобы переместит, detache/отделит HEAD на 4-четыре commit по той ветке на которой находимся.
git branch -f main HEAD~3		напрямую прикрепит ветку main к коммиту при помощи опции -f принудительно переместит ветку main к commit, на три commit родителя назад от HEAD.
git branch -f main [hash]		напрямую прикрепит ветку main к коммиту при помощи опции -f принудительно переместит ветку main к commit с [hash].
git checkout HEAD~1			переместит, detache/отделит HEAD на 1-один commit по той ветке на которой находимся.		
git branch -f bugFix HEAD~1		напрямую прикрепит ветку bugFix к коммиту при помощи опции -f принудительно переместит ветку bugFix к commit, на один commit родителя назад от HEAD.

git reset HEAD~2			отменяет изменения, перенося ссылку по ветке [git status] назад, на более старый коммит. Это своего рода "переписывание истории"; git reset перенесёт ветку назад, как будто некоторых коммитов вовсе и не было. Reset отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи.

git revert HEAD				Чтобы отменить изменения и поделиться отменёнными изменениями с остальными, на ветке по git remote -v
git revert [code_number_of_commit]

git cherry-pick <Commit1> <Commit2> <...> Это очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (HEAD). можем сделать это при помощи команды rebase, которую мы уже прошли, но давай посмотрим, как cherry-pick справится с этой задачей.git cherry-pick прекрасен, когда точно известно, какие коммиты нужны (и известны их точные хеши)
git cherry-pick <from hash2> <to hash4>	- если изменеия в одной ветки, то изменения применятся к коммиту ветки, где сейчас находишься (HEAD).
git cherry-pick <hash2> <hash4>	<hash11>- если изменеия из разных веток, чтобы изменения применились к коммиту ветки, где сейчас находишься (HEAD).
git cherry-pick <hash2> <hash4>	<hash11>- определяет последовательность коммитов в клонированной ветке по git status.
git cherry-pick 			поместит любой коммит сразу после HEAD (только если этот коммит не является предком HEAD)


git rebase -i				если добавить опцию -i, то git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель rebase (target). Также показываются хеши коммитов и комментарии к ним, так что можно легко понять что к чему.
Для "реального" Git, этот интерфейс означает просто открытие файла в редакторе типа vim. После открытия окна интерактивного rebase есть три варианта для каждого коммита:
1\	Можно сменить положение коммита по порядку, переставив строчку с ним в редакторе (у нас в окошке строку с коммитом можно перенести просто мышкой).
2\	Можно "выкинуть" коммит из ребейза. Для этого есть pick - переключение его означает, что нужно выкинуть коммит.
3\	Наконец, можно соединить коммиты, вкратце, при помощи этой функции можно объединять изменения двух коммитов.
git rebase -i HEAD~4			предложит выбор из 4-четырёх последних коммитов с которыми можно совершить действия 1\, 2\ или 3\ для создания/пересборки другой цепи коммитов этой же ветки, на которой находится git status.

git add README.md
git commit --amend			После этой команды откроется редактор, ожидающий ввода описания коммита. Здесь можно поменять сообщение или выйи из редактора, оставив старое. часто разработчики делают коммит и сразу понимают, что забыли добавить часть файлов через git add. Оставшуюся часть изменений можно дослать следующим коммитом. Если изменения еще не были отправлены во внешнюю систему, можно добавить изменения в текущий коммит. Для этого во время коммита добавляется флаг --amend. В реальности --amend не добавляет изменения в существующий коммит. Этот флаг приводит к откату коммита через git reset и выполнению нового коммита с новыми данными. Поэтому мы и видим ровно один коммит, хотя команда git commit выполнялась два раза (первый раз — когда сделали ошибочный коммит). Чтобы не открывался редактор для ввода описания коммита к команде git commit --amend можно добавить опцию --no-edit. В этом случае описание коммита не изменится ветки просто двигать туда-сюда и они часто ссылаются на разные коммиты как на изменения данных в ветке. Ветки просто изменить, они часто временны и постоянно меняют своё состояние. 
В таком случае, где взять постоянную ссылку на момент в истории изменений? 

git tag v0 <hash_commit>		Для таких вещей, как релиз и большие слияния, нужно нечто более постоянное, чем ветка. Tеги, чья основная задача – ссылаться постоянно на конкретный коммит. Важно, что после создания они никогда не сменят своего положения, так что можно с лёгкостью сделать checkout конкретного момента в истории изменений. Теги являются прекрасными ориентирами в истории изменений, поэтому в git есть команда, которая показывает, как далеко текущее состояние от ближайшего тега. И эта команда называется 
git describe <ref>			помогает сориентироваться после отката на много коммитов по истории изменений. Такое может случиться, когда вы сделали git bisect или если вы недавно вернулись из отпуска. <ref> — это что-либо, что указывает на конкретный коммит, например <hash_commit>. Если не указать ref, то git будет считать, что указано текущее положение (HEAD).
Вывод команды выглядит примерно так:
<tag>_<numCommits>_g<hash>		tag – это ближайший тег в истории изменений, 
					numCommits – это на сколько коммитов далеко мы от этого тега, а 
					hash – это хеш коммита, который описывается.
